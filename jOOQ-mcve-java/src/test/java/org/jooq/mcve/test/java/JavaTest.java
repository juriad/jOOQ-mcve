package org.jooq.mcve.test.java;

import java.lang.reflect.Constructor;
import java.sql.Connection;
import java.sql.DriverManager;
import java.util.List;

import org.jooq.Clause;
import org.jooq.Comment;
import org.jooq.Condition;
import org.jooq.Context;
import org.jooq.DDLExportConfiguration;
import org.jooq.DDLQuery;
import org.jooq.DSLContext;
import org.jooq.Index;
import org.jooq.Meta;
import org.jooq.Name;
import org.jooq.OrderField;
import org.jooq.Queries;
import org.jooq.QueryPartInternal;
import org.jooq.Schema;
import org.jooq.SortField;
import org.jooq.Table;
import org.jooq.TableField;
import org.jooq.impl.CustomRecord;
import org.jooq.impl.CustomTable;
import org.jooq.impl.DSL;
import org.jooq.impl.Internal;
import org.jooq.impl.SQLDataType;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;

import static org.junit.Assert.assertTrue;

public class JavaTest {
    public static final Schema PUBLIC = DSL.schema("public");
    public Connection connection;
    public DSLContext ctx;

    @Before
    public void setup() throws Exception {
//        connection = DriverManager.getConnection("jdbc:h2:~/jooq-mcve-java", "sa", "");
        connection = DriverManager.getConnection("jdbc:postgresql://localhost:5431/postgres", "postgres", "postgres");
        ctx = DSL.using(connection);
    }

    @After
    public void after() throws Exception {
        ctx = null;
        connection.close();
        connection = null;
    }

    @Test
    public void test() {
        ctx.dropTableIfExists(TABLE).execute();

        Queries ddl = ctx.ddl(TABLE, new DDLExportConfiguration().createSchemaIfNotExists(true));
        System.out.println(ddl);
        ddl.executeBatch();
        assertTrue(ddl.toString().toLowerCase().contains("where"));

        // the rest is just a play with migrations

        DDLQuery i3 = ctx.createIndex("i3").on(TABLE, TABLE.F).where(TABLE.F.eq(10));
        System.out.println(i3);
        i3.execute();

        Meta db = ctx.meta().filterSchemas(s -> s.getName().equals("public")).filterTables(t -> !t.getName().startsWith("pg_"));

        // HELP ctx.meta(TABLE) ignores schema for indices and migrateTo produces drop + create
        Meta mem = ctx.meta(ctx.ddl(TABLE).queries());

        // HELP produces useless renames
        Queries queries = db.migrateTo(mem);
        System.out.println(queries);
    }

    static MyTable TABLE = new MyTable();

    static class MyTable extends CustomTable<MyRecord> {

        public final TableField<MyRecord, Integer> F;

        protected MyTable() {
            // HELP if I want migrateTo to work, the table must be qualified with schema
            // I did not find any way to create Meta using unqualified table but pretend it is in schema
            // Ideally I don't want to deal with schema anywhere in my code because everything is in public (or whatever is search_path set to)
            super(DSL.name("my_table"), PUBLIC);

            F = createField(DSL.name("f"), SQLDataType.INTEGER);
        }

        @Override
        public Class<MyRecord> getRecordType() {
            return MyRecord.class;
        }

        @Override
        public List<Index> getIndexes() {
            // two different ways to create a partial index
            return List.of(
                    // use delegating wrapper
                    new IndexWithWhere(Internal.createIndex(DSL.name("i1"), this, new OrderField[]{F}, true), F.gt(10)),
                    // use reflection
                    createIndex(DSL.name("i2"), this, new OrderField[]{F}, F.lt(10), true)
            );
        }
    }

    static class MyRecord extends CustomRecord<MyRecord> {
        protected MyRecord() {
            super(TABLE);
        }
    }

    static Index createIndex(Name indexName, Table<?> table, OrderField[] fields, Condition whereCondition, boolean unique) {
        try {
            Class<? extends Index> indexImpl = (Class<? extends Index>) Class.forName("org.jooq.impl.IndexImpl");
            Constructor<? extends Index> newIndexImpl = indexImpl.getDeclaredConstructor(Name.class, Table.class, OrderField[].class, Condition.class,
                    boolean.class);
            newIndexImpl.setAccessible(true);
            return newIndexImpl.newInstance(indexName, table, fields, whereCondition, unique);
        } catch (ReflectiveOperationException e) {
            throw new IllegalStateException("Oh no, we cannot access jooq internals to create an index with a where condition.");
        }
    }

    static class IndexWithWhere implements Index, QueryPartInternal {
        Index index;
        Condition where;

        IndexWithWhere(Index index, Condition where) {
            this.index = index;
            this.where = where;
        }

        @Override
        public Table<?> getTable() {
            return index.getTable();
        }

        @Override
        public List<SortField<?>> getFields() {
            return index.getFields();
        }

        @Override
        public Condition getWhere() {
            return where;
        }

        @Override
        public boolean getUnique() {
            return index.getUnique();
        }

        @Override
        public String getName() {
            return index.getName();
        }

        @Override
        public Name getQualifiedName() {
            return index.getQualifiedName();
        }

        @Override
        public Name getUnqualifiedName() {
            return index.getUnqualifiedName();
        }

        @Override
        public String getComment() {
            return index.getComment();
        }

        @Override
        public Comment getCommentPart() {
            return index.getCommentPart();
        }

        @Override
        public boolean rendersContent(Context<?> context) {
            return ((QueryPartInternal) index).rendersContent(context);
        }

        @Override
        public void accept(Context<?> context) {
            ((QueryPartInternal) index).accept(context);
        }

        @Override
        public Clause[] clauses(Context<?> context) {
            return ((QueryPartInternal) index).clauses(context);
        }

        @Override
        public boolean declaresFields() {
            return ((QueryPartInternal) index).declaresFields();
        }

        @Override
        public boolean declaresTables() {
            return ((QueryPartInternal) index).declaresTables();
        }

        @Override
        public boolean declaresWindows() {
            return ((QueryPartInternal) index).declaresWindows();
        }

        @Override
        public boolean declaresCTE() {
            return ((QueryPartInternal) index).declaresCTE();
        }

        @Override
        public boolean generatesCast() {
            return ((QueryPartInternal) index).generatesCast();
        }
    }
}
